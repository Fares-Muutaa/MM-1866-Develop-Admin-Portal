import { render, screen, fireEvent, waitFor } from "@testing-library/react"
import { ForecastDataTable } from "@/components/rafed-provider/forecast-data-table"
import userEvent from "@testing-library/user-event"
import { vi } from "vitest"

// Mock the fetch function
global.fetch = vi.fn()

// Mock toast component
vi.mock("@/components/ui/use-toast", () => ({
    toast: vi.fn(),
}))

// Helper function to setup fetch mock responses
function mockFetchResponses() {
    // Mock classifications API response
    const mockClassifications = [
        { id: 1, name: "Pharmaceuticals", description: "Pharmaceutical products" },
        { id: 2, name: "Medical Devices", description: "Medical equipment and devices" },
    ]

    // Mock forecast types API response
    const mockForecastTypes = [
        { id: 1, name: "Rafed Forecast", description: "Forecast generated by Rafed", isEditable: false },
        { id: 2, name: "Provider Forecast", description: "Forecast provided by healthcare provider", isEditable: true },
        { id: 3, name: "Historical", description: "Historical data", isEditable: false },
    ]

    // Mock products API response
    const mockProducts = [
        {
            id: 1,
            name: "Paracétamol 500mg",
            description: "Analgésique et antipyrétique courant",
            classificationId: 1,
        },
        { id: 2, name: "Amoxicilline 250mg", description: "Antibiotique à large spectre", classificationId: 1 },
        { id: 3, name: "Moniteur cardiaque", description: "Appareil de surveillance", classificationId: 2 },
    ]

    // Mock first forecast date API response
    const mockFirstDate = { date: "2025-06-01" }

    // Mock forecast data API response
    const mockForecastData = [
        {
            productId: 1,
            forecastTypeId: 1,
            date: "2025-06-01",
            value: 500,
        },
        {
            productId: 1,
            forecastTypeId: 2,
            date: "2025-06-01",
            value: 450,
        },
        {
            productId: 2,
            forecastTypeId: 1,
            date: "2025-06-01",
            value: 300,
        },
        {
            productId: 2,
            forecastTypeId: 2,
            date: "2025-06-01",
            value: 320,
        },
        {
            productId: 3,
            forecastTypeId: 1,
            date: "2025-06-01",
            value: 150,
        },
        {
            productId: 3,
            forecastTypeId: 2,
            date: "2025-06-01",
            value: 140,
        },
    ]

    // Setup fetch mock implementation
    vi.mocked(fetch).mockImplementation((url) => {
        if (url.toString().includes("/api/classifications")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockClassifications),
            } as Response)
        } else if (url.toString().includes("/api/forecast-types")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockForecastTypes),
            } as Response)
        } else if (url.toString().includes("/api/products")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockProducts),
            } as Response)
        } else if (url.toString().includes("/api/forecast-first-date")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockFirstDate),
            } as Response)
        } else if (url.toString().includes("/api/forecast-data-all")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockForecastData),
            } as Response)
        } else if (url.toString().includes("/api/forecast-data") && vi.mocked(fetch).mock.calls[0][1]?.method === "PUT") {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve({ success: true }),
            } as Response)
        }

        return Promise.reject(new Error("Not found"))
    })
}

describe("ForecastDataTable", () => {
    beforeEach(() => {
        vi.clearAllMocks()
        mockFetchResponses()
    })

    test("renders loading state initially", () => {
        render(<ForecastDataTable />)
        expect(screen.getByRole("status")).toBeInTheDocument()
    })

    test("fetches and displays data correctly", async () => {
        render(<ForecastDataTable />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Check if table headers are rendered
        expect(screen.getByText("SKU")).toBeInTheDocument()
        expect(screen.getByText("Product Name")).toBeInTheDocument()
        expect(screen.getByText("Category")).toBeInTheDocument()
        expect(screen.getByText("Rafed Forecast")).toBeInTheDocument()
        expect(screen.getByText("Provider Forecast")).toBeInTheDocument()

        // Check if product data is rendered
        expect(screen.getByText("Paracétamol 500mg")).toBeInTheDocument()
        expect(screen.getByText("Amoxicilline 250mg")).toBeInTheDocument()
        expect(screen.getByText("Moniteur cardiaque")).toBeInTheDocument()
        expect(screen.getByText("Pharmaceuticals")).toBeInTheDocument()
        expect(screen.getByText("Medical Devices")).toBeInTheDocument()
    })

    test("filters data by search term", async () => {
        render(<ForecastDataTable />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Enter search term
        const searchInput = screen.getByPlaceholderText("Search products...")
        fireEvent.change(searchInput, { target: { value: "Paracétamol" } })

        // Check if filtered results are displayed
        expect(screen.getByText("Paracétamol 500mg")).toBeInTheDocument()
        expect(screen.queryByText("Amoxicilline 250mg")).not.toBeInTheDocument()
        expect(screen.queryByText("Moniteur cardiaque")).not.toBeInTheDocument()
    })

    test("filters data by category", async () => {
        const user = userEvent.setup()
        render(<ForecastDataTable />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Open category dropdown
        const categorySelect = screen.getByRole("combobox")
        await user.click(categorySelect)

        // Select "Pharmaceuticals" category
        const pharmaceuticalsOption = screen.getByText("Pharmaceuticals")
        await user.click(pharmaceuticalsOption)

        // Check if filtered results are displayed
        expect(screen.getByText("Paracétamol 500mg")).toBeInTheDocument()
        expect(screen.getByText("Amoxicilline 250mg")).toBeInTheDocument()
        expect(screen.queryByText("Moniteur cardiaque")).not.toBeInTheDocument()
    })

    test("opens edit modal when clicking on editable forecast value", async () => {
        const user = userEvent.setup()
        render(<ForecastDataTable />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Find and click on an editable forecast value (Provider Forecast)
        const editableValues = screen.getAllByText("450")
        await user.click(editableValues[0])

        // Check if edit modal is displayed
        expect(screen.getByText("Edit Forecast Quantity")).toBeInTheDocument()
        expect(screen.getByText("Update the forecast quantity for")).toBeInTheDocument()
        expect(screen.getByLabelText(/New Provider Forecast/i)).toBeInTheDocument()
    })

    test("updates forecast value when saving edit", async () => {
        const user = userEvent.setup()
        const { toast } = await import("@/components/ui/use-toast")

        render(<ForecastDataTable />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Find and click on an editable forecast value (Provider Forecast)
        const editableValues = screen.getAllByText("450")
        await user.click(editableValues[0])

        // Enter new value
        const input = screen.getByLabelText(/New Provider Forecast/i)
        await user.clear(input)
        await user.type(input, "600")

        // Click save button
        const saveButton = screen.getByText("Save Changes")
        await user.click(saveButton)

        // Check if API was called with correct data
        expect(fetch).toHaveBeenCalledWith(
            "/api/forecast-data",
            expect.objectContaining({
                method: "PUT",
                body: expect.stringContaining("600"),
            }),
        )

        // Check if toast was displayed
        await waitFor(() => {
            expect(toast).toHaveBeenCalledWith(
                expect.objectContaining({
                    title: "Forecast updated",
                }),
            )
        })
    })

    test("handles API error when fetching data", async () => {
        // Mock API error
        vi.mocked(fetch).mockImplementationOnce(() => Promise.reject(new Error("API Error")))

        render(<ForecastDataTable />)

        // Wait for loading to complete and check for error handling
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Component should still render with fallback data
        expect(screen.getByText("SKU")).toBeInTheDocument()
        expect(screen.getByText("Product Name")).toBeInTheDocument()
    })
})
