import type React from "react"
import { render, screen, waitFor } from "@testing-library/react"
import { ForecastProductTimeline } from "@/components/rafed-provider/forecast-product-timeline"
import userEvent from "@testing-library/user-event"
import { vi } from "vitest"

// Mock the fetch function
global.fetch = vi.fn()

// Mock toast component
vi.mock("@/components/ui/use-toast", () => ({
    toast: vi.fn(),
}))

// Mock recharts components
vi.mock("recharts", () => {
    const OriginalModule = vi.importActual("recharts")
    return {
        ...OriginalModule,
        ResponsiveContainer: ({ children }: { children: React.ReactNode }) => (
            <div data-testid="responsive-container">{children}</div>
        ),
        LineChart: ({ children }: { children: React.ReactNode }) => <div data-testid="line-chart">{children}</div>,
        Line: () => <div data-testid="chart-line" />,
        XAxis: () => <div data-testid="x-axis" />,
        YAxis: () => <div data-testid="y-axis" />,
        CartesianGrid: () => <div data-testid="cartesian-grid" />,
        Tooltip: () => <div data-testid="tooltip" />,
        Legend: () => <div data-testid="legend" />,
    }
})

// Helper function to setup fetch mock responses
function mockFetchResponses() {
    // Mock forecast types API response
    const mockForecastTypes = [
        { id: 1, name: "Rafed Forecast", description: "Forecast generated by Rafed", isEditable: false },
        { id: 2, name: "Provider Forecast", description: "Forecast provided by healthcare provider", isEditable: true },
        { id: 3, name: "Historical", description: "Historical data", isEditable: false },
    ]

    // Mock products API response
    const mockProducts = [
        {
            id: 1,
            name: "Paracétamol 500mg",
            description: "Analgésique et antipyrétique courant",
            classificationId: 1,
        },
        { id: 2, name: "Amoxicilline 250mg", description: "Antibiotique à large spectre", classificationId: 1 },
        { id: 3, name: "Moniteur cardiaque", description: "Appareil de surveillance", classificationId: 2 },
    ]

    // Mock forecast data API response
    const mockForecastData = [
        // Historical data (past months)
        {
            productId: 1,
            forecastTypeId: 3,
            date: "2024-01-01",
            value: 400,
        },
        {
            productId: 1,
            forecastTypeId: 3,
            date: "2024-02-01",
            value: 420,
        },
        // Current month data
        {
            productId: 1,
            forecastTypeId: 1,
            date: "2024-05-01",
            value: 500,
        },
        {
            productId: 1,
            forecastTypeId: 2,
            date: "2024-05-01",
            value: 480,
        },
        // Future months data
        {
            productId: 1,
            forecastTypeId: 1,
            date: "2024-06-01",
            value: 520,
        },
        {
            productId: 1,
            forecastTypeId: 2,
            date: "2024-06-01",
            value: 510,
        },
        {
            productId: 1,
            forecastTypeId: 1,
            date: "2024-07-01",
            value: 540,
        },
        {
            productId: 1,
            forecastTypeId: 2,
            date: "2024-07-01",
            value: 530,
        },
    ]

    // Setup fetch mock implementation
    vi.mocked(fetch).mockImplementation((url) => {
        if (url.toString().includes("/api/forecast-types")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockForecastTypes),
            } as Response)
        } else if (url.toString().includes("/api/products")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockProducts),
            } as Response)
        } else if (url.toString().includes("/api/forecast-data?productId=1")) {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve(mockForecastData),
            } as Response)
        } else if (url.toString().includes("/api/forecast-data") && vi.mocked(fetch).mock.calls[0][1]?.method === "PUT") {
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve({ success: true }),
            } as Response)
        }

        return Promise.reject(new Error("Not found"))
    })
}

describe("ForecastProductTimeline", () => {
    beforeEach(() => {
        vi.clearAllMocks()
        mockFetchResponses()
    })

    test("renders loading state initially", () => {
        render(<ForecastProductTimeline forecastId="1" />)
        expect(screen.getByRole("status")).toBeInTheDocument()
    })

    test("fetches and displays data correctly", async () => {
        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Check if product selector is rendered with options
        const productSelector = screen.getByRole("combobox")
        expect(productSelector).toBeInTheDocument()

        // Check if chart components are rendered
        expect(screen.getByTestId("responsive-container")).toBeInTheDocument()
        expect(screen.getByTestId("line-chart")).toBeInTheDocument()
        expect(screen.getAllByTestId("chart-line").length).toBeGreaterThan(0)

        // Check if table is rendered with correct headers
        expect(screen.getByText("SKU")).toBeInTheDocument()
        expect(screen.getByText("Product Name")).toBeInTheDocument()
        expect(screen.getByText("Category")).toBeInTheDocument()
        expect(screen.getByText("Date")).toBeInTheDocument()
        expect(screen.getByText("Rafed Forecast")).toBeInTheDocument()
        expect(screen.getByText("Provider Forecast")).toBeInTheDocument()
        expect(screen.getByText("Unit")).toBeInTheDocument()

        // Check if note is displayed
        expect(screen.getByText(/Ce graphique montre les données historiques/)).toBeInTheDocument()
    })

    test("changes product selection", async () => {
        const user = userEvent.setup()
        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Open product dropdown
        const productSelect = screen.getByRole("combobox")
        await user.click(productSelect)

        // Select another product
        const amoxicillineOption = screen.getByText("Amoxicilline 250mg")
        await user.click(amoxicillineOption)

        // Check if API was called with new product ID
        expect(fetch).toHaveBeenCalledWith(expect.stringContaining("/api/forecast-data?productId=2"))
    })

    test("filters out rows with historical data > 0", async () => {
        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Check that table rows are filtered correctly
        // We should see rows for May, June, July but not January, February
        expect(screen.getByText("May 2024")).toBeInTheDocument()
        expect(screen.getByText("Jun 2024")).toBeInTheDocument()
        expect(screen.getByText("Jul 2024")).toBeInTheDocument()
        expect(screen.queryByText("Jan 2024")).not.toBeInTheDocument()
        expect(screen.queryByText("Feb 2024")).not.toBeInTheDocument()
    })

    test("opens edit modal when clicking on editable forecast value", async () => {
        const user = userEvent.setup()
        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Find and click on an editable forecast value (Provider Forecast)
        const editableValues = screen.getAllByText("480")
        await user.click(editableValues[0])

        // Check if edit modal is displayed
        expect(screen.getByText("Edit Forecast Quantity")).toBeInTheDocument()
        expect(screen.getByText(/Update the forecast quantity for/)).toBeInTheDocument()
        expect(screen.getByLabelText(/New Provider Forecast/i)).toBeInTheDocument()
    })

    test("updates forecast value when saving edit", async () => {
        const user = userEvent.setup()
        const { toast } = await import("@/components/ui/use-toast")

        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Find and click on an editable forecast value (Provider Forecast)
        const editableValues = screen.getAllByText("480")
        await user.click(editableValues[0])

        // Enter new value
        const input = screen.getByLabelText(/New Provider Forecast/i)
        await user.clear(input)
        await user.type(input, "600")

        // Click save button
        const saveButton = screen.getByText("Save Changes")
        await user.click(saveButton)

        // Check if API was called with correct data
        expect(fetch).toHaveBeenCalledWith(
            "/api/forecast-data",
            expect.objectContaining({
                method: "PUT",
                body: expect.stringContaining("600"),
            }),
        )

        // Check if toast was displayed
        await waitFor(() => {
            expect(toast).toHaveBeenCalledWith(
                expect.objectContaining({
                    title: "Forecast updated",
                }),
            )
        })
    })

    test("handles API error when fetching data", async () => {
        // Mock API error
        vi.mocked(fetch).mockImplementationOnce(() => Promise.reject(new Error("API Error")))

        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete and check for error handling
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Component should still render with fallback data
        expect(screen.getByTestId("responsive-container")).toBeInTheDocument()
        expect(screen.getByTestId("line-chart")).toBeInTheDocument()
    })

    test("cancels edit without saving", async () => {
        const user = userEvent.setup()
        render(<ForecastProductTimeline forecastId="1" />)

        // Wait for loading to complete
        await waitFor(() => {
            expect(screen.queryByRole("status")).not.toBeInTheDocument()
        })

        // Find and click on an editable forecast value
        const editableValues = screen.getAllByText("480")
        await user.click(editableValues[0])

        // Enter new value
        const input = screen.getByLabelText(/New Provider Forecast/i)
        await user.clear(input)
        await user.type(input, "600")

        // Click cancel button
        const cancelButton = screen.getByText("Cancel")
        await user.click(cancelButton)

        // Check that modal is closed
        expect(screen.queryByText("Edit Forecast Quantity")).not.toBeInTheDocument()

        // Check that API was not called
        expect(fetch).not.toHaveBeenCalledWith(
            "/api/forecast-data",
            expect.objectContaining({
                method: "PUT",
            }),
        )
    })
})
