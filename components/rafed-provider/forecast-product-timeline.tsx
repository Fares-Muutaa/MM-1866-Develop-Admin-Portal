"use client"

import { useState, useEffect } from "react"
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Edit2 } from "lucide-react"
import { toast } from "@/components/ui/use-toast"
import { Separator } from "@/components/ui/separator"

interface ForecastProductTimelineProps {
  forecastId: string
}

interface Product {
  id: number
  name: string
  description?: string
  classificationId?: number
}

interface ForecastType {
  id: number
  name: string
  description?: string
  isEditable: boolean
  color?: string
  lineType?: string // Add lineType property
}

interface TimelineDataPoint {
  month: string
  date: string
  sortDate: Date // Added for proper sorting
  [key: string]: any // This allows for dynamic forecast type keys
}

export function ForecastProductTimeline({ forecastId }: ForecastProductTimelineProps) {
  const [selectedProduct, setSelectedProduct] = useState<string>("")
  const [products, setProducts] = useState<Product[]>([])
  const [forecastTypes, setForecastTypes] = useState<ForecastType[]>([])
  const [timelineData, setTimelineData] = useState<TimelineDataPoint[]>([])
  const [loading, setLoading] = useState(true)
  const [loadingProducts, setLoadingProducts] = useState(true)
  const [loadingForecastTypes, setLoadingForecastTypes] = useState(true)

  // State for edit modal
  const [editModalOpen, setEditModalOpen] = useState(false)
  const [editingItem, setEditingItem] = useState<TimelineDataPoint | null>(null)
  const [editingForecastType, setEditingForecastType] = useState<string>("")
  const [newQuantity, setNewQuantity] = useState<number | "">("")

  // Fetch forecast types from the database
  useEffect(() => {
    const fetchForecastTypes = async () => {
      try {
        const response = await fetch("/api/forecast-types")
        if (!response.ok) {
          throw new Error("Failed to fetch forecast types")
        }
        const data = await response.json()
        setForecastTypes(data)
      } catch (error) {
        console.error("Error fetching forecast types:", error)
        // Fallback to mock data if API fails
        setForecastTypes([
          {
            id: 1,
            name: "Rafed Forecast",
            description: "Forecast generated by Rafed",
            isEditable: false,
            color: "#8884d8",
            lineType: "5 5", // Dashed line
          },
          {
            id: 2,
            name: "Provider Forecast",
            description: "Forecast provided by healthcare provider",
            isEditable: true,
            color: "#82ca9d",
            lineType: "3 3", // Dotted line
          },
          {
            id: 3,
            name: "Historical",
            description: "Historical data",
            isEditable: false,
            color: "#ff7300",
            lineType: "", // Solid line
          },
        ])
      } finally {
        setLoadingForecastTypes(false)
      }
    }

    fetchForecastTypes()
  }, [])

  // Fetch products from the database
  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const response = await fetch("/api/products")
        if (!response.ok) {
          throw new Error("Failed to fetch products")
        }
        const data = await response.json()
        // Sort products alphabetically by name
        const sortedProducts = data.sort((a: Product, b: Product) =>
            a.name.localeCompare(b.name, "fr", { sensitivity: "base" }),
        )

        setProducts(sortedProducts)
        if (sortedProducts.length > 0) {
          setSelectedProduct(sortedProducts[0].id.toString())
        }
      } catch (error) {
        console.error("Error fetching products:", error)
        // Fallback to mock data if API fails
        const mockProducts = [
          { id: 1, name: "Paracétamol 500mg", description: "Analgésique et antipyrétique courant" },
          { id: 2, name: "Amoxicilline 250mg", description: "Antibiotique à large spectre" },
          { id: 3, name: "Insuline Lantus", description: "Insuline à action prolongée" },
          { id: 4, name: "Moniteur cardiaque", description: "Appareil de surveillance des fonctions cardiaques" },
          { id: 5, name: "Ventilateur médical", description: "Appareil d'assistance respiratoire" },
        ]
        setProducts(mockProducts)
        setSelectedProduct(mockProducts[0].id.toString())
      } finally {
        setLoadingProducts(false)
      }
    }

    fetchProducts()
  }, [])

  // Fetch timeline data for selected product
  useEffect(() => {
    if (selectedProduct && forecastTypes.length > 0) {
      setLoading(true)

      const fetchForecastData = async () => {
        try {
          const response = await fetch(`/api/forecast-data?productId=${selectedProduct}`)
          if (!response.ok) {
            throw new Error("Failed to fetch forecast data")
          }
          const data = await response.json()

          // Process the data to format it for the chart
          const processedData = processTimelineData(data, forecastTypes)
          setTimelineData(processedData)
        } catch (error) {
          console.error("Error fetching forecast data:", error)
          // Generate mock data as fallback
          generateMockTimelineData()
        } finally {
          setLoading(false)
        }
      }

      fetchForecastData()
    }
  }, [selectedProduct, forecastTypes])

  // Process timeline data from API response with improved ordering
  const processTimelineData = (data: any[], forecastTypes: ForecastType[]) => {
    // Group data by date
    const groupedByDate = data.reduce((acc: any, item: any) => {
      const date = new Date(item.date)
      const monthYear = date.toLocaleString("default", { month: "short" }) + " " + date.getFullYear()

      if (!acc[monthYear]) {
        acc[monthYear] = {
          month: monthYear,
          date: monthYear,
          sortDate: date, // Store the actual date object for sorting
        }
      }

      // Find the forecast type name
      const forecastType = forecastTypes.find((ft) => ft.id === item.forecastTypeId)
      if (forecastType) {
        const typeName = forecastType.name.replace(/\s+/g, "")
        acc[monthYear][typeName] = Number(item.value)
      }

      return acc
    }, {})

    // Convert to array and sort by date
    return Object.values(groupedByDate)
        .sort((a: any, b: any) => a.sortDate.getTime() - b.sortDate.getTime())
        .map((item: any) => {
          // Format the month name properly
          const date = item.sortDate
          const monthName = date.toLocaleString("default", { month: "short" })
          const year = date.getFullYear()

          return {
            ...item,
            month: `${monthName} ${year}`,
            date: `${monthName} ${year}`,
          }
        })
  }

  // Generate mock timeline data as fallback with proper ordering
  const generateMockTimelineData = () => {
    const mockTimelineData: TimelineDataPoint[] = []

    // Generate data for the past 12 months and future 12 months
    const today = new Date()
    const startDate = new Date(today.getFullYear() - 1, today.getMonth(), 1) // 12 months ago

    // Generate 24 months of data (12 past + 12 future)
    for (let i = 0; i < 24; i++) {
      const currentDate = new Date(startDate)
      currentDate.setMonth(startDate.getMonth() + i)

      const monthName = currentDate.toLocaleString("default", { month: "short" })
      const year = currentDate.getFullYear()
      const monthYear = `${monthName} ${year}`

      const dataPoint: TimelineDataPoint = {
        month: monthYear,
        date: monthYear,
        sortDate: new Date(currentDate), // Store the date object for sorting
      }

      // Add data for each forecast type
      forecastTypes.forEach((type) => {
        const typeName = type.name.replace(/\s+/g, "")

        // Past months are historical data (only if type is Historical)
        if (i < 12 && type.name === "Historical Data") {
          dataPoint[typeName] = Math.floor(Math.random() * 1000) + 500
        }
        // Current month has data for all types
        else if (i === 12) {
          dataPoint[typeName] = Math.floor(Math.random() * 1000) + 500
        }
        // Future months only have forecast data (not historical)
        else if (i > 12 && type.name !== "Historical Data") {
          dataPoint[typeName] = Math.floor(Math.random() * 1000) + 500
        }
      })

      mockTimelineData.push(dataPoint)
    }

    setTimelineData(mockTimelineData)
  }

  const handleProductChange = (value: string) => {
    setSelectedProduct(value)
  }

  const handleEditClick = (item: TimelineDataPoint, forecastType: string) => {
    setEditingItem(item)
    setEditingForecastType(forecastType)
    setNewQuantity(item[forecastType] || 0)
    setEditModalOpen(true)
  }

  const handleSaveEdit = async () => {
    if (editingItem && editingForecastType && newQuantity !== "") {
      try {
        // Find the forecast type ID
        const forecastType = forecastTypes.find((ft) => ft.name.replace(/\s+/g, "") === editingForecastType)

        if (!forecastType) {
          throw new Error("Forecast type not found")
        }

        // Use the sortDate for the API call
        const dateToUse = editingItem.sortDate || new Date(editingItem.date)

        // Prepare data for API
        const updateData = {
          productId: selectedProduct,
          forecastTypeId: forecastType.id,
          date: dateToUse.toISOString(),
          value: Number(newQuantity),
        }

        // Call API to update forecast data
        const response = await fetch("/api/forecast-data", {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updateData),
        })

        if (!response.ok) {
          throw new Error("Failed to update forecast data")
        }

        // Update the local state
        const updatedData = timelineData.map((item) => {
          if (item.month === editingItem.month) {
            return {
              ...item,
              [editingForecastType]: Number(newQuantity),
            }
          }
          return item
        })

        setTimelineData(updatedData)

        // Show success toast
        toast({
          title: "Forecast updated",
          description: `Updated ${forecastType.name} for ${editingItem.month} to ${newQuantity}`,
        })
      } catch (error) {
        console.error("Error updating forecast:", error)
        toast({
          title: "Update failed",
          description: "Failed to update forecast data. Please try again.",
          variant: "destructive",
        })
      } finally {
        // Close the modal
        setEditModalOpen(false)
        setEditingItem(null)
        setEditingForecastType("")
        setNewQuantity("")
      }
    }
  }

  // Get the selected product details
  const selectedProductDetails = products.find((p) => p.id.toString() === selectedProduct) || {
    name: "",
    description: "",
    classificationId: 0,
  }

  if ((loadingProducts || loadingForecastTypes) && !products.length) {
    return (
        <div className="flex h-[400px] items-center justify-center">
          <div className="h-8 w-8 animate-spin rounded-full border-2 border-primary border-t-transparent"></div>
        </div>
    )
  }

  // Get dynamic color for forecast type with fallback
  const getForecastTypeColor = (type: ForecastType, fallbackIndex: number) => {
    // Use the color from the database if available
    if (type.color && type.color.trim() !== "") {
      return type.color
    }

    // Fallback to predefined colors if no color is set in the database
    const fallbackColors = ["#8884d8", "#82ca9d", "#ff7300", "#0088FE", "#00C49F", "#FFBB28"]
    return fallbackColors[fallbackIndex % fallbackColors.length]
  }

  // Get dynamic line type (stroke dash array) for forecast type with fallback
  const getForecastTypeLineType = (type: ForecastType) => {
    // Use the lineType from the database if available
    if (type.lineType !== undefined) {
      return type.lineType
    }

    // Fallback: Historical is solid, others are dashed
    return type.name === "Historical Data" ? undefined : "5 5"
  }

  // Find the Historical type and its name for display
  const historicalType = forecastTypes.find((type) => type.name === "Historical Data")
  const historicalTypeName = historicalType?.name.replace(/\s+/g, "")

  // Filter forecast types for the table (exclude Historical)
  const forecastOnlyTypes = forecastTypes.filter((type) => type.name !== "Historical Data")

  // All types for the table (including Historical)
  const allTableTypes = [...forecastOnlyTypes]



  // Function to render a line sample with the correct style
  const renderLineSample = (type: ForecastType, index: number) => {
    const color = getForecastTypeColor(type, index)
    const lineType = getForecastTypeLineType(type)

    // Create a style for the line based on the lineType
    let borderStyle = "solid"
    let borderWidth = "2px"

    if (lineType === "5 5") {
      borderStyle = "dashed"
    } else if (lineType === "3 3") {
      borderStyle = "dotted"
    } else if (lineType === "10 5") {
      borderStyle = "dashed"
      borderWidth = "3px"
    }

    return (
        <div
            className="w-6 h-0 inline-block align-middle"
            style={{
              borderBottom: `${borderWidth} ${borderStyle} ${color}`,
              marginRight: "6px",
            }}
        />
    )
  }

  return (
      <div className="space-y-6">
        <div className="w-full max-w-xs">
          <Select value={selectedProduct} onValueChange={handleProductChange}>
            <SelectTrigger>
              <SelectValue placeholder="Select a product" />
            </SelectTrigger>
            <SelectContent>
              {products.map((product) => (
                  <SelectItem key={product.id} value={product.id.toString()}>
                    {product.name}
                  </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>

        {loading ? (
            <div className="flex h-[300px] items-center justify-center">
              <div className="h-8 w-8 animate-spin rounded-full border-2 border-primary border-t-transparent"></div>
            </div>
        ) : (
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={timelineData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis />
                <Tooltip />
                <Legend />
                {forecastTypes.map((type, index) => {
                  const typeName = type.name.replace(/\s+/g, "")
                  const hasData = timelineData.some((item) => item[typeName] !== undefined)

                  if (!hasData) return null

                  return (
                      <Line
                          key={type.id}
                          type="monotone"
                          dataKey={typeName}
                          name={type.name}
                          stroke={getForecastTypeColor(type, index)}
                          strokeDasharray={getForecastTypeLineType(type)}
                          connectNulls
                      />
                  )
                })}
              </LineChart>
            </ResponsiveContainer>
        )}

        <div className="rounded-md bg-muted/50 p-3 text-sm">
          <p>
  <span className="font-medium">Note:</span> This chart shows historical data and forecasts for the selected product over time.
</p>
        </div>



        {/* Separator between chart and table */}
        <Separator className="my-6" />

        {/* Forecast Data Table */}
        <div>
          <h3 className="text-lg font-medium mb-3">Forecast Data for {selectedProductDetails.name}</h3>
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>SKU</TableHead>
                  <TableHead>Product Name</TableHead>
                  <TableHead>Category</TableHead>
                  <TableHead>Date</TableHead>
                  {allTableTypes.map((type, index) => (
                      <TableHead key={type.id} className="text-right">
                        <div className="flex items-center justify-end gap-2">
                          <div
                              className="w-3 h-3 rounded-full border border-gray-300"
                              style={{ backgroundColor: getForecastTypeColor(type, index) }}
                          />
                          {type.name}
                        </div>
                      </TableHead>
                  ))}
                  <TableHead>Unit</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {timelineData.length > 0 ? (
                    timelineData
                        .filter((item) => {
                          // Check if the item has any forecast data (excluding Historical)
                          const hasForecastData = forecastOnlyTypes.some((type) => {
                            const typeName = type.name.replace(/\s+/g, "")
                            return item[typeName] !== undefined && item[typeName] > 0
                          })

                          // Include the item only if it has forecast data
                          return hasForecastData
                        })
                        .map((item, index) => {
                          return (
                              <TableRow key={index}>
                                <TableCell className="font-medium">
                                  {selectedProductDetails.name?.substring(0, 4).toUpperCase() +
                                      "-" +
                                      selectedProduct.padStart(4, "0")}
                                </TableCell>
                                <TableCell>{selectedProductDetails.name}</TableCell>
                                <TableCell>
                                  {selectedProductDetails.classificationId === 1
                                      ? "Pharmaceuticals"
                                      : selectedProductDetails.classificationId === 2
                                          ? "Medical Devices"
                                          : "Other"}
                                </TableCell>
                                <TableCell>{item.date}</TableCell>
                                {allTableTypes.map((type, typeIndex) => {
                                  const typeName = type.name.replace(/\s+/g, "")
                                  return (
                                      <TableCell key={type.id} className="text-right">
                                        {type.isEditable ? (
                                            <button
                                                onClick={() => handleEditClick(item, typeName)}
                                                className="inline-flex items-center text-primary hover:underline focus:outline-none"
                                            >
                                              {item[typeName]?.toLocaleString() || 0}
                                              <Edit2 className="ml-1 h-3 w-3 text-muted-foreground" />
                                            </button>
                                        ) : (
                                            item[typeName]?.toLocaleString() || 0
                                        )}
                                      </TableCell>
                                  )
                                })}
                                <TableCell>Units</TableCell>
                              </TableRow>
                          )
                        })
                ) : (
                    <TableRow>
                      <TableCell colSpan={6 + allTableTypes.length} className="h-24 text-center">
                        No forecast data available.
                      </TableCell>
                    </TableRow>
                )}
              </TableBody>
            </Table>
          </div>
        </div>

        {/* Edit Forecast Modal */}
        <Dialog open={editModalOpen} onOpenChange={setEditModalOpen}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Edit Forecast Quantity</DialogTitle>
              <DialogDescription>
                Update the forecast quantity for {selectedProductDetails.name} ({editingItem?.month})
              </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              {forecastTypes.map((type, index) => {
                const typeName = type.name.replace(/\s+/g, "")
                if (editingItem && editingItem[typeName] !== undefined && typeName !== editingForecastType) {
                  return (
                      <div key={type.id} className="grid grid-cols-4 items-center gap-4">
                        <label className="text-right text-sm font-medium col-span-2">
                          <div className="flex items-center justify-end gap-2">
                            {renderLineSample(type, index)}
                            {type.name}:
                          </div>
                        </label>
                        <div className="col-span-2 font-medium">{editingItem[typeName]?.toLocaleString() || 0} Units</div>
                      </div>
                  )
                }
                return null
              })}

              {editingForecastType && (
                  <div className="grid grid-cols-4 items-center gap-4">
                    <label htmlFor="new-forecast" className="text-right text-sm font-medium col-span-2">
                      New{" "}
                      {forecastTypes.find((ft) => ft.name.replace(/\s+/g, "") === editingForecastType)?.name || "Forecast"}:
                    </label>
                    <div className="col-span-2">
                      <Input
                          id="new-forecast"
                          type="number"
                          value={newQuantity}
                          onChange={(e) => setNewQuantity(e.target.value === "" ? "" : Number(e.target.value))}
                          min={0}
                          className="w-full"
                      />
                    </div>
                  </div>
              )}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setEditModalOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleSaveEdit} disabled={newQuantity === ""}>
                Save Changes
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
  )
}
